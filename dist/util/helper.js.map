{"version":3,"file":"helper.js","sources":["../../src/util/helper.ts"],"sourcesContent":["// @ts-ignore\nimport { getValue } from '@glimmer/tracking/primitives/cache';\n// @ts-ignore\nimport { invokeHelper } from '@ember/helper';\n\nimport { DEFAULT_THUNK, normalizeThunk } from '../core/utils';\n\nimport type { Cache, Thunk } from '../core/types';\nimport type ClassBasedHelper from '@ember/component/helper';\nimport type { FunctionBasedHelper } from '@ember/component/helper';\nimport type { HelperLike } from '@glint/template';\n\ntype Get<T, K, Otherwise = unknown> = K extends keyof T ? T[K] : Otherwise;\n\n/**\n * <div class=\"callout note\">\n *\n * This is not a core part of ember-resources, but is an example utility to demonstrate a concept when authoring your own resources. However, this utility is still under the broader library's SemVer policy.\n *\n * A consuming app will not pay for the bytes of this utility unless imported.\n *\n * </div>\n *\n * implemented with raw `invokeHelper` API, no classes from `ember-resources` used.\n *\n * -----------------------\n *\n * Enables the use of template-helpers in JavaScript\n *\n * Note that it should be preferred to use regular functions in javascript\n * whenever possible, as the runtime cost of \"things as resources\" is non-0.\n * For example, if using `@ember/component/helper` utilities, it's a common p\n * practice to split the actual behavior from the framework construct\n * ```js\n * export function plainJs() {}\n *\n * export default helper(() => plainJs())\n * ```\n * so in this case `plainJs` can be used separately.\n *\n * This differentiation makes less of a difference since\n * [plain functions as helpers](https://github.com/emberjs/rfcs/pull/756)\n * will be supported soon.\n *\n * @example\n * ```js\n * import intersect from 'ember-composable-helpers/addon/helpers/intersect';\n *\n * import { helper } from 'ember-resources/util/helper';\n *\n * class Demo {\n *   @tracked listA = [...];\n *   @tracked listB = [...]\n *\n *   intersection = helper(this, intersect, () => [this.listA, this.listB])\n *\n *   toString = (array) => array.join(', ');\n * }\n * ```\n * ```hbs\n * {{this.toString this.intersection.value}}\n * ```\n */\nexport function helper<T = unknown, S = InferSignature<T>, Return = Get<S, 'Return'>>(\n  context: object,\n  helper: T,\n  thunk: Thunk = DEFAULT_THUNK\n): { value: Return } {\n  let resource: Cache<unknown>;\n\n  return {\n    get value(): Return {\n      if (!resource) {\n        resource = invokeHelper(context, helper, () => {\n          return normalizeThunk(thunk);\n        }) as Cache<unknown>;\n      }\n\n      return getValue<Return>(resource)!; // eslint-disable-line\n    },\n  };\n}\n\ntype InferSignature<T> = T extends HelperLike<infer S>\n  ? S\n  : T extends FunctionBasedHelper<infer S>\n  ? S\n  : T extends ClassBasedHelper<infer S>\n  ? S\n  : 'Signature not found';\n"],"names":["helper","context","thunk","DEFAULT_THUNK","resource","value","invokeHelper","normalizeThunk","getValue"],"mappings":";;;;AAAA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,MAAMA,CACpBC,OAAe,EACfD,MAAS,EACTE,KAAY,GAAGC,aAAa,EACT;AACnB,EAAA,IAAIC,QAAwB,CAAA;EAE5B,OAAO;IACL,IAAIC,KAAKA,GAAW;MAClB,IAAI,CAACD,QAAQ,EAAE;AACbA,QAAAA,QAAQ,GAAGE,YAAY,CAACL,OAAO,EAAED,MAAM,EAAE,MAAM;UAC7C,OAAOO,cAAc,CAACL,KAAK,CAAC,CAAA;AAC9B,SAAC,CAAmB,CAAA;AACtB,OAAA;AAEA,MAAA,OAAOM,QAAQ,CAASJ,QAAQ,CAAC,CAAE;AACrC,KAAA;GACD,CAAA;AACH;;;;"}